"""
Handlers required by the web operations
"""

import uuid
import os
import json
from yadacoin.basehandlers import BaseHandler
from yadacoin.graphutils import GraphUtils as GU
from yadacoin.blockchainutils import BU


class BaseWebHandler(BaseHandler):

    def prepare(self):

        if self.request.protocol == 'http' and self.config.ssl:
            self.redirect('https://' + self.request.host + self.request.uri, permanent=False)


class HomeHandler(BaseHandler):

    async def get(self):
        """
        :return:
        """
        self.render(
            "index.html",
            yadacoin=self.yadacoin_vars,
            username=self.get_secure_cookie("username"),
            rid=self.get_secure_cookie("rid")
        )


class MultifactorAuthHandler(BaseHandler):
    async def get(self):
        redirect = self.get_query_argument('redirect', None)
        origin = self.get_query_argument('origin')
        if not origin:
            return '{"error": "origin not in query params"}', 400
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)
        config = self.config
        rid = self.get_query_argument('rid')
        if not rid:
            return '{"error": "rid not in query params"}', 400

        txn_id = self.get_query_argument('id')

        cookie = self.get_secure_cookie("signin_code")
        if cookie:
            cookie = cookie.decode('utf-8')
        else:
            cookie = str(uuid.uuid4())
            self.set_secure_cookie("signin_code", cookie)

        result = GU().verify_message(
            rid,
            cookie,
            config.public_key,
            txn_id.replace(' ', '+'))

        if result[1]:
            self.set_secure_cookie("rid", rid)

            username = await self.config.mongo.async_db.name_server.find_one({'rid': rid})
            self.set_secure_cookie("username", username['txn']['relationship']['their_username'])


            if redirect:
                return self.redirect(redirect)
            else:
                return self.render_as_json({
                    'authenticated': True
                })
        
        return self.render_as_json({
            'authenticated': False
        })

class LoginHandler(BaseHandler):

    async def get(self):
        origin = self.get_query_argument('origin')
        if not origin:
            return '{"error": "origin not in query params"}', 400
        
        # TODO: protect this endpoint with information that could only be generated by the identity!
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)

        cookie = self.get_secure_cookie("signin_code")
        if cookie:
            cookie = cookie.decode('utf-8')
        else:
            cookie = str(uuid.uuid4())
            self.set_secure_cookie("signin_code", cookie)

        self.render_as_json({
            'signin_code': cookie
        })

class RemoteMultifactorAuthHandler(BaseHandler):
    async def post(self):
        args = json.loads(self.request.body)
        origin = args.get('origin', '*')
        redirect = args.get('redirect')
        signin_code = args.get('signin_code')

        if not signin_code:
            return self.render_as_json({'error': 'missing params'}), 400
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)
        config = self.config

        result = await self.config.mongo.async_db.verify_message_cache.find_one({
            'message.signIn': signin_code
        })

        if result:
            self.set_secure_cookie("rid", result['rid'])

            username = await self.config.mongo.async_db.name_server.find_one({'rid': result['rid']})
            self.set_secure_cookie("username", username['txn']['relationship']['their_username'])

            result = await self.config.mongo.async_db.verify_message_cache.delete_one({
                'message.signIn': signin_code
            })
            if redirect:
                return self.redirect(redirect)
            else:
                return self.render_as_json({
                    'authenticated': True
                })
        
        return self.render_as_json({
            'authenticated': False
        })


class LogoutHandler(BaseHandler):

    def get(self):
        redirect = self.get_query_argument('redirect', None)

        if self.get_secure_cookie("signin_code"):
            self.set_secure_cookie("signin_code", '')

        if self.get_secure_cookie("rid"):
            self.set_secure_cookie("rid", '')

        if self.get_secure_cookie("username"):
            self.set_secure_cookie("username", '')

        if redirect:
            self.redirect(redirect)
        else:
            self.render_as_json({
                'authenticated': False
            })

class HashrateAPIHandler(BaseHandler):

    async def get(self):
        max_target = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        config = self.config
        blocks = config.BU.get_blocks()
        total_nonce = 0
        periods = []
        last_time = None
        for block in blocks:
            difficulty = max_target / int(block.get('target'), 16)
            if block.get('index') == 0:
                start_timestamp = block.get('time')
            if last_time:
                if int(block.get('time')) > last_time:
                    periods.append({
                        'hashrate': (((int(block.get('index')) / 144) * difficulty) * 2**32) / 600 / 100,
                        'index': block.get('index'),
                        'elapsed_time': (int(block.get('time')) - last_time)
                    })
            last_time = int(block.get('time'))
            total_nonce += block.get('nonce')
        sorted(periods, key=lambda x: x['index'])
        total_time_elapsed = int(block.get('time')) - int(start_timestamp)
        network_hash_rate =  total_nonce / int(total_time_elapsed)
        self.render_as_json({
            'stats': {
                'network_hash_rate': network_hash_rate,
                'total_time_elapsed': total_time_elapsed,
                'total_nonce': total_nonce,
                'periods': periods
            }
        })


class AppHandler(BaseWebHandler):

    def prepare(self):
        if self.request.protocol == 'https':
            self.redirect('http://' + self.request.host + self.request.uri, permanent=False)

    async def get(self):
        """
        :return:
        """
        self.render("app.html")


WEB_HANDLERS = [
    (r'/', HomeHandler),
    (r'/mfa', MultifactorAuthHandler),
    (r'/login', LoginHandler),
    (r'/rmfa', RemoteMultifactorAuthHandler),
    (r'/logout', LogoutHandler),
    (r'/api-stats', HashrateAPIHandler),
    (r'/app', AppHandler),
]
